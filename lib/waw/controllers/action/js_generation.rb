module Waw
  class ActionController < ::Waw::Controller
    
    # Eigen-class methods
    class << self

      # Returns known controllers
      def controllers
        @controllers ||= []
      end
        
      # When ActionController is inherited, we keep a reference
      # for later code generation and add a start hook
      def inherited(child)
        controllers << child
        Waw.add_start_hook(JSGeneration.new) if controllers.size==1
      end

    end # class << self
    
    class JSGeneration
      
      # Raises a ConfigurationError
      def error(msg)
        raise ConfigurationError, msg
      end
      
      # Start hook start callback required by Waw. Generates the javascript code
      # if the configuration variable 'code_at_startup' is true. 
      def run
        return unless Waw.config.code_at_startup
        
        # Now, find the StaticController, that should be installed
        static = Waw.find_rack_app {|app| ::Waw::StaticController===app}
        error("Code generation expects a ::Waw::StaticController being installed.") if static.nil?
        
        # Find the folder now
        folder = File.join(Waw.root_folder, static.root_folder, 'js')
        error("Code generation expects #{folder} to be an existing directory.") unless File.directory?(folder)
        
        # Look for the application name
        appname = Waw.config.knows?(:application_name) ? Waw.config.application_name : 'waw'
        
        # And let's go now!
        file = File.join(folder, "#{appname}_generated.js")
        File.open(file, 'w') do |buffer|
          generate_js(buffer)
        end
      end  
      
      # Generate the javascript code for installed action controllers.
      def generate_js(buffer)
        buffer << <<-EOF
        /* This file is automatically generated by Waw. Any edit will probably be lost
         * next time the application is started. */

        EOF
        generate_js_messages(buffer)
        ActionController.controllers.sort{|c1, c2| c1.class.name <=> c2.class.name}.each do |controller|
          # Let find the URL for this controller
          url = Waw.find_url_of(controller)
          unless url
            Waw.logger.warn("Skipping #{controller}, which does not seem to be mapped to an URL")
          else
            buffer << <<-EOF
              /*
               * Actions contributed by #{controller}, mapped to #{url}
               */
            EOF
            controller.actions.keys.sort{|k1, k2| k1.to_s <=> k2.to_s}.each do |name|
              action = controller.actions[name]
              generate_js_for_action(url, action, buffer)
            end
          end
        end
      end
    
      # Generates the javascript code for message resources.
      def generate_js_messages(buffer)
        if Waw.resources.has_resource?(:messages)
          buffer << "/* Messages, from waw.resources.messages */\n"
          messages = {}
          Waw.resources.messages.each do |name, value|
            messages[name] = value 
          end  
          buffer << "var messages = new Array();\n"
          messages.keys.sort{|k1, k2| k1.to_s <=> k2.to_s}.each do |name|
            value = messages[name]
            buffer << "messages['#{name}'] = \"#{value}\";\n"    
          end
        end
      end
    
      # Generates the javascript code for a given action
      def generate_js_for_action(path, action, buffer)
        buffer << <<-THEEND
        function #{action.public_id}(request_data, form) {
          $.ajax({type: "POST", url: "#{path}/#{action.public_id}", data: request_data, dataType: "json",
            error: function(data) {
        		  window.location = '/feedback?mkey=server_error'
        		},
        		success: function(data) {
              #{action.routing.generate_js_routing(action, 18)}
        		}
        	});
        	return false;
        }  
        THEEND
      end
      
    end # class JSGeneration
  end # class ActionController
end # module Waw